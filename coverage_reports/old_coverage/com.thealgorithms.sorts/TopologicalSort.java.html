<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TopologicalSort.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java</a> &gt; <a href="index.source.html" class="el_package">com.thealgorithms.sorts</a> &gt; <span class="el_source">TopologicalSort.java</span></div><h1>TopologicalSort.java</h1><pre class="source lang-java linenums">package com.thealgorithms.sorts;

import java.util.*;

/**
 * The Topological Sorting algorithm linearly orders a DAG or Directed Acyclic Graph into
 * a linked list. A Directed Graph is proven to be acyclic when a DFS or Depth First Search is
 * performed, yielding no back-edges.
 *
 * https://en.wikipedia.org/wiki/Topological_sorting
 *
 * @author Jonathan Taylor (https://github.com/Jtmonument)
 * Based on Introduction to Algorithms 3rd Edition
 */
<span class="nc" id="L15">public class TopologicalSort {</span>

    /*
     * Enum to represent the colors for the depth first search
     * */
<span class="nc" id="L20">    private enum Color {</span>
<span class="nc" id="L21">        WHITE,</span>
<span class="nc" id="L22">        GRAY,</span>
<span class="nc" id="L23">        BLACK,</span>
    }

    /*
     * Class to represent vertices
     * */
    private static class Vertex {

        /*
         * Name of vertex
         * */
        public final String label;

        /*
         * Weight of vertex
         * (more accurately defined as the time that a vertex has begun a visit in DFS)
         * */
        public int weight;

        /*
         * The time that the vertex has finished a visit in DFS
         * */
        public int finished;

        /*
         * π parent of the vertex
         * */
        public Vertex predecessor;

        /*
         * Represents the category of visit in DFS
         * */
<span class="nc" id="L55">        public Color color = Color.WHITE;</span>

        /*
         * The array of names of descendant vertices
         * */
<span class="nc" id="L60">        public final ArrayList&lt;String&gt; next = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L62">        public Vertex(String label) {</span>
<span class="nc" id="L63">            this.label = label;</span>
<span class="nc" id="L64">        }</span>
    }

    /*
     * Graph class uses the adjacency list representation
     * */
<span class="nc" id="L70">    static class Graph {</span>

        /*
         * Adjacency list representation
         * */
<span class="nc" id="L75">        private final HashMap&lt;String, Vertex&gt; adj = new LinkedHashMap&lt;&gt;();</span>

        /*
         * Function to add an edge to the graph
         * */
        public void addEdge(String label, String... next) {
<span class="nc" id="L81">            adj.put(label, new Vertex(label));</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">            if (!next[0].isEmpty()) Collections.addAll(</span>
<span class="nc" id="L83">                adj.get(label).next,</span>
                next
            );
<span class="nc" id="L86">        }</span>
    }

    static class BackEdgeException extends RuntimeException {

        public BackEdgeException(String backEdge) {
<span class="nc" id="L92">            super(</span>
                &quot;This graph contains a cycle. No linear ordering is possible. &quot; +
                backEdge
            );
<span class="nc" id="L96">        }</span>
    }

    /*
     * Time variable in DFS
     * */
    private static int time;

    /*
     * Depth First Search
     *
     * DFS(G)
     *   for each vertex u ∈ G.V
     *       u.color = WHITE
     *       u.π = NIL
     *   time = 0
     *   for each vertex u ∈ G.V
     *   if u.color == WHITE
     *       DFS-VISIT(G, u)
     *
     * Performed in Θ(V + E) time
     * */
    public static LinkedList&lt;String&gt; sort(Graph graph) {
<span class="nc" id="L119">        LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L120">        graph.adj.forEach((name, vertex) -&gt; {</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">            if (vertex.color == Color.WHITE) {</span>
<span class="nc" id="L122">                list.addFirst(sort(graph, vertex, list));</span>
            }
<span class="nc" id="L124">        });</span>
<span class="nc" id="L125">        return list;</span>
    }

    /*
     * Depth First Search Visit
     *
     * DFS-Visit(G, u)
     *   time = time + 1
     *   u.d = time
     *   u.color = GRAY
     *   for each v ∈ G.Adj[u]
     *       if v.color == WHITE
     *           v.π = u
     *           DFS-Visit(G, u)
     *   u.color = BLACK
     *   time = time + 1
     *   u.f = time
     * */
    private static String sort(Graph graph, Vertex u, LinkedList&lt;String&gt; list) {
<span class="nc" id="L144">        time++;</span>
<span class="nc" id="L145">        u.weight = time;</span>
<span class="nc" id="L146">        u.color = Color.GRAY;</span>
<span class="nc" id="L147">        graph.adj</span>
<span class="nc" id="L148">            .get(u.label)</span>
<span class="nc" id="L149">            .next.forEach(label -&gt; {</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">                if (graph.adj.get(label).color == Color.WHITE) {</span>
<span class="nc" id="L151">                    graph.adj.get(label).predecessor = u;</span>
<span class="nc" id="L152">                    list.addFirst(sort(graph, graph.adj.get(label), list));</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">                } else if (graph.adj.get(label).color == Color.GRAY) {</span>
                    /*
                     * A back edge exists if an edge (u, v) connects a vertex u to its ancestor vertex v
                     * in a depth first tree. If v.d ≤ u.d &lt; u.f ≤ v.f
                     *
                     * In many cases, we will not know u.f, but v.color denotes the type of edge
                     * */
<span class="nc" id="L160">                    throw new BackEdgeException(</span>
                        &quot;Back edge: &quot; + u.label + &quot; -&gt; &quot; + label
                    );
                }
<span class="nc" id="L164">            });</span>
<span class="nc" id="L165">        u.color = Color.BLACK;</span>
<span class="nc" id="L166">        time++;</span>
<span class="nc" id="L167">        u.finished = time;</span>
<span class="nc" id="L168">        return u.label;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>